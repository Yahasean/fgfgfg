<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Web 3D City Runner V7.1 (Head Control)</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; background: #87CEEB; touch-action: none; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; z-index: 10;
        }
        #score-board {
            padding: 20px; color: #fff; font-size: 28px; font-weight: 900;
            text-shadow: 2px 2px 0 #000; -webkit-text-stroke: 1px black;
            display: flex; justify-content: space-between;
        }
        #powerup-status { color: #00ff00; text-shadow: 0 0 10px #00ff00; }
        
        #ui-bottom {
            flex-grow: 1; display: flex; justify-content: center; align-items: flex-end; padding-bottom: 50px;
            pointer-events: none;
        }
        .message-box {
            background: rgba(0,0,0,0.7); color: #fff; padding: 15px 30px; border-radius: 50px;
            font-size: 24px; font-weight: bold; border: 2px solid #fff;
            animation: fadeUp 2s forwards;
        }
        @keyframes fadeUp {
            0% { opacity: 0; transform: translateY(20px); }
            20% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        /* --- è§¸æ§æŒ‰éˆ• (æ‰‹æ©Ÿæ¨¡å¼) --- */
        .control-btn {
            position: absolute; bottom: 40px; width: 80px; height: 80px;
            border-radius: 50%; color: white; font-weight: 900; font-size: 30px;
            display: flex; align-items: center; justify-content: center;
            pointer-events: auto; backdrop-filter: blur(4px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        .control-btn:active { transform: scale(0.9); }
        #btn-fire { right: 30px; background: rgba(255, 50, 50, 0.4); border: 3px solid rgba(255, 255, 255, 0.6); font-size: 18px; }
        #btn-fire:active { background: rgba(255, 50, 50, 0.7); }
        #btn-left { left: 30px; background: rgba(255, 255, 255, 0.2); border: 3px solid rgba(255, 255, 255, 0.5); }
        #btn-right { left: 130px; background: rgba(255, 255, 255, 0.2); border: 3px solid rgba(255, 255, 255, 0.5); }
        @media (min-width: 1024px) { .control-btn { display: none; } }

        /* --- æ”åƒé ­é è¦½è¦–çª— --- */
        #camera-preview {
            position: absolute; top: 20px; left: 20px; width: 160px; height: 120px;
            background: #000; border: 2px solid #fff; border-radius: 10px;
            z-index: 20; display: none; overflow: hidden; pointer-events: auto;
        }
        #camera-video { display: none; } 
        #camera-canvas { width: 100%; height: 100%; transform: scaleX(-1); /* é¡åƒé¡¯ç¤º */ }
        #face-status {
            position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(0,0,0,0.6);
            color: #0f0; font-size: 10px; text-align: center; padding: 2px 0; white-space: nowrap;
        }

        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; backdrop-filter: blur(8px); z-index: 99;
        }

        h1 { 
            color: #FFD700; font-size: 50px; margin: 0 0 10px 0; 
            text-shadow: 4px 4px 0 #000; font-style: italic; letter-spacing: 3px; text-align: center;
        }

        .setup-panel {
            background: rgba(255,255,255,0.1); padding: 20px 30px; border-radius: 20px;
            border: 2px solid rgba(255,255,255,0.2); display: flex; flex-direction: column; gap: 20px; margin-bottom: 20px;
            max-width: 90%;
        }
        .row-group { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        .select-group { display: flex; flex-direction: column; align-items: flex-start; }
        .select-group label { color: #00ffff; font-size: 14px; margin-bottom: 5px; font-weight: bold; }
        
        select {
            padding: 8px 12px; font-size: 16px; border-radius: 8px; border: none;
            background: #fff; cursor: pointer; outline: none; min-width: 160px;
        }

        button {
            padding: 15px 60px; font-size: 24px; cursor: pointer;
            background: linear-gradient(45deg, #00e5ff, #2979ff);
            border: 3px solid #fff; border-radius: 50px; color: white;
            font-weight: bold; box-shadow: 0 6px 0 #004ba0, 0 10px 10px rgba(0,0,0,0.3);
            transition: 0.1s; text-transform: uppercase;
        }
        button:active { transform: translateY(4px); box-shadow: 0 2px 0 #004ba0; }
        
        #loading-text { margin-top: 15px; color: #aaa; font-size: 13px; text-align: center; line-height: 1.6; max-width: 80%; }
    </style>
</head>
<body>

    <div id="camera-preview">
        <video id="camera-video"></video>
        <canvas id="camera-canvas"></canvas>
        <div id="face-status">ç­‰å¾…æ”åƒé ­...</div>
    </div>

    <div id="ui-layer">
        <div id="score-board">
            <div>SCORE: <span id="score-val">0</span> | COINS: <span id="coin-val">0</span></div>
            <div id="powerup-status">GUN: <span id="shots-val">Lv.1</span></div>
        </div>
        
        <div id="btn-left" class="control-btn dir-btn" onclick="moveLane(-1)">â†</div>
        <div id="btn-right" class="control-btn dir-btn" onclick="moveLane(1)">â†’</div>
        <div id="btn-fire" class="control-btn" onclick="fireBullet()">FIRE</div>

        <div id="ui-bottom">
            <div id="message-display"></div>
        </div>
    </div>

    <div id="start-screen" class="overlay">
        <h1>CITY RUNNER</h1>
        <div class="setup-panel">
            <div class="row-group">
                <div class="select-group">
                    <label>ğŸ® æ§åˆ¶æ–¹å¼</label>
                    <select id="control-mode">
                        <option value="normal">éµç›¤ / è§¸æ§ (é è¨­)</option>
                        <option value="camera">ğŸ“· é ­éƒ¨é«”æ„Ÿæ§åˆ¶ (V7.1)</option>
                    </select>
                </div>
            </div>
            <div class="row-group">
                <div class="select-group">
                    <label>ğŸƒ è§’è‰²æ¨¡å‹</label>
                    <select id="player-selector">
                        <option value="player.glb">é è¨­è§’è‰²</option>
                        <option value="player2.glb">è§’è‰² B</option>
                        <option value="none">æ–¹å¡Šäºº</option>
                    </select>
                </div>
                <div class="select-group">
                    <label>ğŸš§ éšœç¤™ç‰©æ¨¡å‹</label>
                    <select id="obstacle-selector">
                        <option value="obstacle.glb">é è¨­éšœç¤™</option>
                        <option value="obstacle2.glb">éšœç¤™ B</option>
                        <option value="none">ç´…ç®±å­</option>
                    </select>
                </div>
            </div>
        </div>
        <button onclick="initGame()">START GAME</button>
        <div id="loading-text">
            <b>æ™®é€šæ¨¡å¼ï¼š</b> [â†/â†’]ç§»å‹• | [Space/ä¸Šæ»‘]è·³èº | [Z/æŒ‰éˆ•]å°„æ“Š<br>
            <b>é¡é ­æ¨¡å¼ï¼š</b> é ­è½‰å·¦/å³(ç§»å‹•) | æŠ¬é ­(è·³èº) | å¼µå˜´(å°„æ“Š)
        </div>
    </div>

    <div id="game-over-screen" class="overlay" style="display: none;">
        <h1 style="color: #ff4444;">CRASHED!</h1>
        <p style="color:white; font-size: 24px;">FINAL SCORE: <span id="final-score">0</span></p>
        <button onclick="location.reload()">RETRY</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // --- è®Šæ•¸å®£å‘Š ---
        let controlMode = 'normal';
        let cameraObj = null;
        let faceMesh = null;
        let lastActionTime = 0;
        const ACTION_COOLDOWN = 400; 

        // --- MediaPipe Face Mesh é‚è¼¯ ---
        const videoElement = document.getElementById('camera-video');
        const canvasElement = document.getElementById('camera-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const faceStatus = document.getElementById('face-status');

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // ç¹ªè£½ç¶²æ ¼ (è¦–è¦ºå›é¥‹)
                drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, {color: '#C0C0C050', lineWidth: 0.5});
                // å¼·èª¿é¼»å­å’Œè‡‰é °ï¼Œæ–¹ä¾¿å°æº–
                const keyPoints = [1, 234, 454, 10, 152]; // é¼», å³è‡‰, å·¦è‡‰, é ‚, ä¸‹å·´
                for(let i of keyPoints) {
                    const p = landmarks[i];
                    canvasCtx.beginPath();
                    canvasCtx.arc(p.x * canvasElement.width, p.y * canvasElement.height, 3, 0, 2*Math.PI);
                    canvasCtx.fillStyle = "#00FF00"; canvasCtx.fill();
                }

                detectGestures(landmarks);
            } else {
                faceStatus.innerText = "æœªåµæ¸¬åˆ°è‡‰éƒ¨";
            }
            canvasCtx.restore();
        }

        // æ ¸å¿ƒåµæ¸¬é‚è¼¯ï¼šæ”¹ç‚ºã€Œè½‰é ­ã€èˆ‡ã€ŒæŠ¬é ­ã€
        function detectGestures(landmarks) {
            const now = Date.now();
            
            // é—œéµé»ç´¢å¼•
            const nose = landmarks[1];
            const rightCheek = landmarks[234]; // ä½¿ç”¨è€…çš„å³è‡‰é ° (ç•«é¢å·¦å´)
            const leftCheek = landmarks[454];  // ä½¿ç”¨è€…çš„å·¦è‡‰é ° (ç•«é¢å³å´)
            const upperLip = landmarks[13];
            const lowerLip = landmarks[14];
            const midEye = landmarks[168]; // å…©çœ¼ä¹‹é–“ (çœ‰å¿ƒä¸‹æ–¹)

            // 1. å·¦å³è½‰é ­ (Yaw Calculation)
            // åŸç†ï¼šè¨ˆç®—é¼»å­åˆ°å·¦å³è‡‰é °çš„æ°´å¹³è·é›¢ã€‚
            // ç•¶é ­å‘å³è½‰ï¼Œé¼»å­æœƒé è¿‘å³è‡‰é °(234)ï¼Œé é›¢å·¦è‡‰é °(454)ã€‚
            const distToRight = Math.abs(nose.x - rightCheek.x);
            const distToLeft = Math.abs(nose.x - leftCheek.x);
            
            // è½‰é ­åˆ¤æ–·é–¾å€¼ (æ¯”ä¾‹)
            // å¦‚æœä¸€é‚Šçš„è·é›¢æ˜¯å¦ä¸€é‚Šçš„ 0.6 å€ä»¥ä¸‹ï¼Œåˆ¤å®šç‚ºè½‰é ­
            const turnThreshold = 0.6; 

            // 2. æŠ¬é ­ (Pitch Calculation)
            // åŸç†ï¼šè¨ˆç®—é¼»å­(1)èˆ‡çœ‰å¿ƒ(168)çš„å‚ç›´è·é›¢ (yè»¸)ã€‚
            // æ­£å¸¸æƒ…æ³ä¸‹ nose.y > midEye.y (é¼»å­åœ¨çœ‰å¿ƒä¸‹æ–¹)ã€‚
            // æŠ¬é ­æ™‚ï¼Œé¼»å­åœ¨ç•«é¢ä¸­æœƒã€Œå‡é«˜ã€ï¼Œèˆ‡çœ‰å¿ƒçš„Yè»¸è·é›¢è®ŠçŸ­ã€‚
            const verticalDist = nose.y - midEye.y;
            const lookUpThreshold = 0.035; // æ•¸å€¼è¶Šå°ä»£è¡¨æŠ¬å¾—è¶Šé«˜ (éœ€è¦æ ¹æ“šå¯¦éš›èª¿æ•´)

            // 3. å¼µå˜´
            const mouthOpen = Math.abs(upperLip.y - lowerLip.y);
            const mouthThreshold = 0.05;

            // --- å‹•ä½œè§¸ç™¼ (åŒ…å«å†·å»æ™‚é–“) ---

            // é¡¯ç¤ºç‹€æ…‹æ•¸æ“šæ–¹ä¾¿èª¿è©¦
            // console.log(`R:${distToRight.toFixed(2)} L:${distToLeft.toFixed(2)} V:${verticalDist.toFixed(3)}`);

            // å„ªå…ˆæ¬Šï¼šå°„æ“Š > è·³èº > ç§»å‹•
            if (mouthOpen > mouthThreshold) {
                if (now - lastActionTime > 200) {
                    fireBullet();
                    faceStatus.innerText = "ğŸ”¥ å¼µå˜´å°„æ“Š!";
                    lastActionTime = now;
                }
                return;
            }

            if (verticalDist < lookUpThreshold) {
                // æŠ¬é ­åˆ¤å®š
                if (!isJumping) {
                    isJumping = true; jumpVelocity = jumpStrength; playSFX('jump');
                    faceStatus.innerText = "â« æŠ¬é ­è·³èº!";
                    lastActionTime = now;
                } else {
                    faceStatus.innerText = "â« ä¿æŒæŠ¬é ­";
                }
                return;
            }

            if (now - lastActionTime > ACTION_COOLDOWN) {
                // å‘å³è½‰ (é¼»å­é è¿‘å³è‡‰é °)
                if (distToRight < distToLeft * turnThreshold) {
                    if (currentLane < 1) {
                        moveLane(1);
                        faceStatus.innerText = "â¡ï¸ é ­è½‰å³";
                        lastActionTime = now;
                    }
                }
                // å‘å·¦è½‰ (é¼»å­é è¿‘å·¦è‡‰é °)
                else if (distToLeft < distToRight * turnThreshold) {
                    if (currentLane > -1) {
                        moveLane(-1);
                        faceStatus.innerText = "â¬…ï¸ é ­è½‰å·¦";
                        lastActionTime = now;
                    }
                } else {
                    faceStatus.innerText = "ğŸ˜ åµæ¸¬ä¸­...";
                }
            }
        }

        async function startCamera() {
            faceStatus.innerText = "å•Ÿå‹•æ”åƒé ­...";
            document.getElementById('camera-preview').style.display = 'block';
            
            faceMesh = new FaceMesh({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
            }});
            
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            faceMesh.onResults(onResults);

            if(typeof Camera !== 'undefined') {
                cameraObj = new Camera(videoElement, {
                    onFrame: async () => {
                        await faceMesh.send({image: videoElement});
                    },
                    width: 320,
                    height: 240
                });
                await cameraObj.start();
            } else {
                alert("ç„¡æ³•è¼‰å…¥ç›¸æ©Ÿåº«ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·š");
            }
        }

        // --- éŠæˆ²æ ¸å¿ƒä»£ç¢¼ (ä¿ç•™åŸæœ‰æ¶æ§‹) ---
        
        // éŸ³æ•ˆ
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let bgmInterval;
        let noteIndex = 0;
        const melody = [330, 330, 330, 440, 523, 523, 440, 0, 392, 392, 349, 349, 330, 0, 0, 0];

        function playTone(freq, type, duration, vol, delay = 0) {
            if(freq <= 0) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime + delay);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime + delay);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + delay + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(audioCtx.currentTime + delay);
            osc.stop(audioCtx.currentTime + delay + duration);
        }

        function startBGM() {
            if(bgmInterval) clearInterval(bgmInterval);
            bgmInterval = setInterval(() => {
                const note = melody[noteIndex % melody.length];
                playTone(note, 'triangle', 0.15, 0.05);
                if (noteIndex % 4 === 0) playTone(100, 'square', 0.1, 0.03);
                noteIndex++;
            }, 200);
        }

        function playSFX(type) {
            if (type === 'jump') playTone(400, 'sine', 0.3, 0.1);
            if (type === 'coin') playTone(1500, 'square', 0.1, 0.05);
            if (type === 'crash') playTone(60, 'sawtooth', 0.6, 0.2);
            if (type === 'shoot') playTone(800, 'square', 0.05, 0.05);
            if (type === 'hit') { playTone(200, 'sine', 0.1, 0.1); playTone(100, 'square', 0.2, 0.1, 0.05); }
            if (type === 'powerup') { playTone(600, 'triangle', 0.1, 0.1); playTone(900, 'triangle', 0.1, 0.1, 0.1); }
        }

        function showMessage(text) {
            const display = document.getElementById('message-display');
            display.innerHTML = ''; 
            const msg = document.createElement('div');
            msg.className = 'message-box';
            msg.innerText = text;
            display.appendChild(msg);
            setTimeout(() => { if(display.contains(msg)) display.removeChild(msg); }, 2000);
        }

        // å ´æ™¯
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 30, 120);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 400);
        camera.position.set(0, 3.5, 8);
        camera.lookAt(0, 1, -10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // ç‡ˆå…‰
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8); scene.add(hemiLight);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(50, 100, 50); dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.left = -50; dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50; dirLight.shadow.camera.bottom = -50;
        scene.add(dirLight);

        // ç’°å¢ƒ
        const roadGeo = new THREE.PlaneGeometry(14, 1000);
        const roadMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI / 2; road.position.z = -400;
        road.receiveShadow = true; scene.add(road);

        const stripes = [];
        const stripeGeo = new THREE.PlaneGeometry(0.5, 4);
        const stripeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        for(let i=0; i<30; i++) {
            const sL = new THREE.Mesh(stripeGeo, stripeMat);
            const sR = new THREE.Mesh(stripeGeo, stripeMat);
            sL.rotation.x = -Math.PI/2; sR.rotation.x = -Math.PI/2;
            sL.position.set(-2.5, 0.02, -i*10); sR.position.set(2.5, 0.02, -i*10);
            scene.add(sL); scene.add(sR); stripes.push(sL, sR);
        }

        const buildings = [];
        const buildingColors = [0x88CCFF, 0xFFAAAA, 0xAAFFAA, 0xFFEEAA, 0xCCCCCC];
        const bGeo = new THREE.BoxGeometry(1, 1, 1);
        function createBuilding(x, z) {
            const h = 10 + Math.random() * 30;
            const w = 5 + Math.random() * 5; const d = 5 + Math.random() * 5;
            const color = buildingColors[Math.floor(Math.random() * buildingColors.length)];
            const bMat = new THREE.MeshPhongMaterial({ color: color });
            const mesh = new THREE.Mesh(bGeo, bMat);
            mesh.position.set(x, h/2, z); mesh.scale.set(w, h, d);
            mesh.castShadow = true; mesh.receiveShadow = true;
            scene.add(mesh); buildings.push(mesh);
        }
        for(let i=0; i<40; i++) {
            createBuilding(-20 - Math.random()*30, -i * 15);
            createBuilding(20 + Math.random()*30, -i * 15);
        }

        const clouds = [];
        const cloudGeo = new THREE.BoxGeometry(4, 2, 3);
        const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
        for(let i=0; i<15; i++) {
            const cloud = new THREE.Mesh(cloudGeo, cloudMat);
            cloud.position.set((Math.random()*60)-30, 15 + Math.random()*10, -i*20);
            scene.add(cloud); clouds.push(cloud);
        }

        // è¼‰å…¥å™¨
        const loader = new THREE.GLTFLoader();
        let playerGroup = new THREE.Group(); scene.add(playerGroup);
        let playerMesh, mixer;
        let obstacleModel = null;
        let coinModel = null;
        let powerupModel = null;

        const ts = new Date().getTime();
        loader.load('coin.glb?v='+ts, (g) => { coinModel = g.scene; coinModel.traverse(n=>{if(n.isMesh){n.castShadow=true; n.material.color.setHex(0xFFD700);}}); }, undefined, ()=>{});
        loader.load('powerup.glb?v='+ts, (g) => { powerupModel = g.scene; powerupModel.traverse(n=>{if(n.isMesh){n.castShadow=true; n.material.color.setHex(0x00FF00);}}); }, undefined, ()=>{});

        let currentLane = 0; let isJumping = false; let jumpVelocity = 0;
        const gravity = -0.03; const jumpStrength = 0.6;
        let gameActive = false; let score = 0; let totalCoinsCollected = 0; let gameSpeed = 0.4;
        
        const bullets = []; const bulletSpeed = 1.5;
        const bulletGeo = new THREE.SphereGeometry(0.2, 8, 8);
        const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
        let shotsPerFire = 1; let powerupTimer = null;

        const obstacles = []; const coins = []; const powerups = [];

        function loadPlayer(filename) {
            while(playerGroup.children.length > 0) playerGroup.remove(playerGroup.children[0]); 
            if (filename === 'none') {
                const g = new THREE.BoxGeometry(1,1.5,1); const m = new THREE.MeshPhongMaterial({color: 0x00ffcc});
                playerMesh = new THREE.Mesh(g, m); playerMesh.position.y = 0.75; playerMesh.castShadow = true;
                playerGroup.add(playerMesh); return;
            }
            loader.load(filename + '?v=' + new Date().getTime(), (gltf) => {
                playerMesh = gltf.scene; playerMesh.scale.set(0.8, 0.8, 0.8); playerMesh.rotation.y = Math.PI;
                playerMesh.traverse(n => { if(n.isMesh) n.castShadow = true; });
                playerGroup.add(playerMesh);
                if(gltf.animations.length > 0) { mixer = new THREE.AnimationMixer(playerMesh); mixer.clipAction(gltf.animations[0]).play(); }
            }, undefined, () => { loadPlayer('none'); });
        }

        function loadObstacleTemplate(filename) {
            obstacleModel = null; if(filename === 'none') return;
            loader.load(filename + '?v=' + new Date().getTime(), (gltf) => {
                obstacleModel = gltf.scene; obstacleModel.traverse(n => { if(n.isMesh) n.castShadow = true; });
            }, undefined, ()=>{});
        }

        function spawnObject() {
            if(!gameActive) return;
            const lane = Math.floor(Math.random()*3)-1; const zPos = -120;
            const rnd = Math.random();
            if(rnd < 0.6) { // éšœç¤™ç‰©
                let obs = obstacleModel ? obstacleModel.clone() : new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshPhongMaterial({color:0xff4444}));
                obs.position.set(lane*2.5, 1, zPos); obs.userData = {type:'obstacle'};
                scene.add(obs); obstacles.push(obs);
            } else if (rnd < 0.9) { // é‡‘å¹£
                for(let i=0; i<3; i++) {
                    let c = coinModel ? coinModel.clone() : new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,0.1,16), new THREE.MeshPhongMaterial({color:0xffff00}));
                    if(!coinModel) c.rotation.x = Math.PI/2;
                    c.position.set(lane*2.5, 1, zPos - i*3); c.userData = {active:true, type:'coin'};
                    scene.add(c); coins.push(c);
                }
            } else { // é“å…·
                let p = powerupModel ? powerupModel.clone() : new THREE.Mesh(new THREE.SphereGeometry(0.7), new THREE.MeshPhongMaterial({color:0x00ff00}));
                p.position.set(lane*2.5, 1, zPos); p.userData = {active:true, type:'powerup'};
                scene.add(p); powerups.push(p);
            }
        }

        setInterval(spawnObject, 1000);
        setInterval(()=>{ if(gameActive && gameSpeed < 1.8) gameSpeed += 0.002; }, 1000);

        function moveLane(direction) {
            if(!gameActive) return;
            if(direction === -1 && currentLane > -1) currentLane--;
            if(direction === 1 && currentLane < 1) currentLane++;
        }

        function fireBullet() {
            if(!gameActive) return;
            playSFX('shoot');
            const spread = shotsPerFire > 1 ? (shotsPerFire - 1) * 0.5 : 0;
            for (let i = 0; i < shotsPerFire; i++) {
                const b = new THREE.Mesh(bulletGeo, bulletMat);
                const startX = playerGroup.position.x - spread / 2 + (i * (spread / (shotsPerFire > 1 ? shotsPerFire - 1 : 1)));
                b.position.set(startX, playerGroup.position.y + 0.5, playerGroup.position.z);
                scene.add(b); bullets.push(b);
            }
        }

        function initGame() {
            controlMode = document.getElementById('control-mode').value;
            
            if (controlMode === 'camera') {
                startCamera();
                document.querySelectorAll('.control-btn').forEach(el => el.style.display = 'none');
                showMessage("ğŸ“· é¡é ­æ¨¡å¼ï¼šè«‹ç¢ºä¿è‡‰éƒ¨åœ¨å·¦ä¸Šè§’æ¡†å…§");
            } else {
                if(window.innerWidth < 1024) {
                    document.querySelectorAll('.control-btn').forEach(el => el.style.display = 'flex');
                }
            }

            loadPlayer(document.getElementById('player-selector').value);
            loadObstacleTemplate(document.getElementById('obstacle-selector').value);
            document.getElementById('start-screen').style.display = 'none';
            gameActive = true; if(audioCtx.state === 'suspended') audioCtx.resume();
            startBGM();
        }

        // éµç›¤ç›£è½
        document.addEventListener('keydown', (e) => {
            if(!gameActive) return;
            if(e.key === 'ArrowLeft') moveLane(-1);
            if(e.key === 'ArrowRight') moveLane(1);
            if((e.key === 'ArrowUp' || e.code === 'Space') && !isJumping) { isJumping = true; jumpVelocity = jumpStrength; playSFX('jump'); }
            if(e.key === 'z' || e.key === 'Z') fireBullet();
        });

        // è§¸æ§ (ä¸Šæ»‘è·³èº)
        let touchStartX = 0; let touchStartY = 0; const swipeThreshold = 30;
        document.addEventListener('touchstart', (e) => {
            if(!gameActive) return;
            touchStartX = e.changedTouches[0].screenX; touchStartY = e.changedTouches[0].screenY;
        }, {passive: false});
        document.addEventListener('touchend', (e) => {
            if(!gameActive) return;
            let yDiff = e.changedTouches[0].screenY - touchStartY;
            if (Math.abs(yDiff) > swipeThreshold && yDiff < 0 && !isJumping) {
                isJumping = true; jumpVelocity = jumpStrength; playSFX('jump');
            }
        }, {passive: false});

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if(mixer) mixer.update(delta);

            stripes.forEach(s => { s.position.z += gameSpeed; if(s.position.z > 10) s.position.z = -290; });
            buildings.forEach(b => { b.position.z += gameSpeed; if(b.position.z > 20) { b.position.z = -580; b.scale.y = 10+Math.random()*30; b.position.y = b.scale.y/2; }});
            clouds.forEach(c => { c.position.z += gameSpeed*0.5; if(c.position.z > 20) { c.position.z = -300; c.position.x = (Math.random()*60)-30; }});

            if(!gameActive) return;

            playerGroup.position.x += (currentLane*2.5 - playerGroup.position.x) * 0.15;
            if(isJumping) { playerGroup.position.y += jumpVelocity; jumpVelocity += gravity; if(playerGroup.position.y<=0){playerGroup.position.y=0; isJumping=false;} } 
            else { playerGroup.position.y = 0; }

            for(let i=bullets.length-1; i>=0; i--) {
                let b = bullets[i]; b.position.z -= bulletSpeed;
                for(let j=obstacles.length-1; j>=0; j--) {
                    let obs = obstacles[j];
                    if(b.position.distanceTo(obs.position) < 1.8) {
                        playSFX('hit'); scene.remove(b); bullets.splice(i,1); scene.remove(obs); obstacles.splice(j,1);
                        score+=100; document.getElementById('score-val').innerText = score; break;
                    }
                }
                if(b.position.z < -100) { scene.remove(b); bullets.splice(i,1); }
            }

            for(let i=obstacles.length-1; i>=0; i--) {
                obstacles[i].position.z += gameSpeed;
                if(Math.abs(obstacles[i].position.z - playerGroup.position.z)<1.5 && 
                   Math.abs(obstacles[i].position.x - playerGroup.position.x)<1.0 && playerGroup.position.y < 1.5) gameOver();
                if(obstacles[i].position.z > 10) { scene.remove(obstacles[i]); obstacles.splice(i,1); score+=10; document.getElementById('score-val').innerText=score; }
            }

            coins.forEach(c => c.rotation.y += 0.1);
            for(let i=coins.length-1; i>=0; i--) {
                let c = coins[i]; c.position.z += gameSpeed;
                if(c.userData.active && Math.abs(c.position.z-playerGroup.position.z)<1.5 && Math.abs(c.position.x-playerGroup.position.x)<1.0 && Math.abs(playerGroup.position.y-c.position.y)<1.5) {
                    c.userData.active = false; scene.remove(c); coins.splice(i,1);
                    totalCoinsCollected++; score+=50; document.getElementById('coin-val').innerText=totalCoinsCollected; document.getElementById('score-val').innerText=score; playSFX('coin');
                } else if(c.position.z > 10) { scene.remove(c); coins.splice(i,1); }
            }

            powerups.forEach(p => p.rotation.y += 0.05);
            for(let i=powerups.length-1; i>=0; i--) {
                let p = powerups[i]; p.position.z += gameSpeed;
                if(p.userData.active && Math.abs(p.position.z-playerGroup.position.z)<1.5 && Math.abs(p.position.x-playerGroup.position.x)<1.0 && Math.abs(playerGroup.position.y-p.position.y)<1.5) {
                    p.userData.active = false; scene.remove(p); powerups.splice(i,1);
                    playSFX('powerup'); showMessage("ğŸ”¥ 3é€£ç™¼æ¨¡å¼å•Ÿå‹•ï¼");
                    shotsPerFire = 3; document.getElementById('shots-val').innerText = "Lv.MAX";
                    if(powerupTimer) clearTimeout(powerupTimer);
                    powerupTimer = setTimeout(() => { shotsPerFire = 1; document.getElementById('shots-val').innerText = "Lv.1"; showMessage("âš ï¸ æ­¦å™¨ç³»çµ±å†·å»"); }, 10000);
                } else if(p.position.z > 10) { scene.remove(p); powerups.splice(i,1); }
            }
            renderer.render(scene, camera);
        }

        function gameOver() {
            gameActive = false; clearInterval(bgmInterval); playSFX('crash');
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>
